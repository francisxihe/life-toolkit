---
description: ç¼–å†™desktop Repositoryä»£ç æ—¶
alwaysApply: false
---

# Desktop Repository å®ç°è§„èŒƒ

## ğŸ“‹ æ¦‚è¿°

Desktop Repository ä½äº `apps/desktop/src/database/{module}/` ç›®å½•ä¸­ï¼Œè´Ÿè´£å®ç°æœ¬åœ° SQLite æ•°æ®åº“çš„æ•°æ®è®¿é—®é€»è¾‘ï¼Œé€‚é…æ¡Œé¢ç«¯åº”ç”¨çš„æ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢éœ€æ±‚ã€‚

## ğŸ—ï¸ åŸºç¡€æ¶æ„

### æ–‡ä»¶ç»“æ„
```
apps/desktop/src/database/{module}/
â””â”€â”€ {module}.repository.ts     # Desktop Repository å®ç°
```

### å¯¼å…¥è§„èŒƒ
```typescript
// 1. å¯¼å…¥ TypeORM ç›¸å…³ç±»
import { Repository } from "typeorm";
import { AppDataSource } from "../../database.config";

// 2. å¯¼å…¥ Business Layer Interface å’Œç±»å‹
import {
  CreateModuleDto,
  UpdateModuleDto,
  ModulePageFiltersDto,
  ModuleListFilterDto,
  ModuleDto,
  ModuleMapper,
  Module,
} from "@life-toolkit/business-server";

// 3. å¯¼å…¥æšä¸¾å’Œç±»å‹
import { ModuleStatus } from "@life-toolkit/enum";
```

## ğŸ“‹ å®ç°è§„èŒƒ

### åŸºç¡€ Repository å®ç°
```typescript
export class ModuleRepository {
  private repo: Repository<Module> = AppDataSource.getRepository(Resource);

  // æŸ¥è¯¢æ¡ä»¶æ„å»ºå™¨
  private buildQuery(filter: ModuleListFilterDto) {
    const qb = this.repo
      .createQueryBuilder("module")
      .leftJoinAndSelect("module.related", "related");

    // åŠ¨æ€æ¡ä»¶æ„å»º
    if (filter.status !== undefined) {
      qb.andWhere("module.status = :status", { status: filter.status });
    }
    if (filter.importance !== undefined) {
      qb.andWhere("module.importance = :importance", {
        importance: filter.importance,
      });
    }
    if (filter.keyword) {
      qb.andWhere("module.title LIKE :kw", { kw: `%${filter.keyword}%` });
    }
    if (filter.planDateStart) {
      qb.andWhere("module.planDate >= :ds", { ds: filter.planDateStart });
    }
    if (filter.planDateEnd) {
      qb.andWhere("module.planDate <= :de", { de: filter.planDateEnd });
    }
    if (filter.relatedId) {
      qb.andWhere("module.relatedId = :relatedId", { relatedId: filter.relatedId });
    }

    return qb;
  }

  // å®ç° Business Interface ä¸­çš„æ–¹æ³•
  async create(createDto: CreateModuleDto): Promise<ModuleDto> {
    const entity = this.repo.create({
      title: createDto.title,
      description: createDto.description,
      status: createDto.status ?? ModuleStatus.PENDING,
      importance: createDto.importance,
      tags: createDto.tags,
      planDate: createDto.planDate,
      relatedId: createDto.relatedId,
    });
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async createWithExtras(
    createDto: CreateModuleDto,
    extras: Partial<Resource>
  ): Promise<ResourceDto> {
    const entity = this.repo.create({
      name: createDto.name,
      description: createDto.description,
      status: createDto.status ?? ModuleStatus.ACTIVE,
      importance: createDto.importance,
      urgency: createDto.urgency,
      tags: createDto.tags,
      planDate: createDto.planDate,
      planStartAt: createDto.planStartAt,
      planEndAt: createDto.planEndAt,
      relatedId: createDto.relatedId,
      type: ResourceType.MANUAL,
      ...extras,
    });
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async findByFilter(filter: ModuleListFilterDto): Promise<ResourceDto[]> {
    const qb = this.buildQuery(filter);
    const list = await qb.orderBy("resource.createdAt", "DESC").getMany();
    return list.map((item) => ModuleDto.importEntity(item));
  }

  async page(filter: ModulePageFiltersDto): Promise<{
    list: ResourceDto[];
    total: number;
    pageNum: number;
    pageSize: number;
  }> {
    const { pageNum = 1, pageSize = 10 } = filter;
    const qb = this.buildQuery(filter);

    const [list, total] = await qb
      .skip((pageNum - 1) * pageSize)
      .take(pageSize)
      .orderBy("resource.createdAt", "DESC")
      .getManyAndCount();

    return {
      list: list.map((item) => ModuleDto.importEntity(item)),
      total,
      pageNum,
      pageSize,
    };
  }

  async update(id: string, updateDto: UpdateModuleDto): Promise<ResourceDto> {
    const entity = await this.repo.findOne({ where: { id } });
    if (!entity) throw new Error("Resource not found");

    updateDto.exportUpdateEntity(entity);
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async batchUpdate(
    includeIds: string[],
    updateDto: UpdateModuleDto
  ): Promise<ResourceDto[]> {
    await this.repo.update(includeIds, updateDto);
    const qb = this.repo
      .createQueryBuilder("resource")
      .leftJoinAndSelect("resource.relatedEntity", "relatedEntity")
      .leftJoinAndSelect("resource.anotherEntity", "anotherEntity");

    const list = await qb
      .where("resource.id IN (:...ids)", { ids: includeIds })
      .getMany();

    return list.map((item) => ModuleDto.importEntity(item));
  }

  async delete(id: string): Promise<boolean> {
    await this.repo.delete(id);
    return true;
  }

  async deleteByFilter(filter: ModulePageFiltersDto): Promise<void> {
    const qb = this.repo.createQueryBuilder("resource");
    if (filter.relatedIds && filter.relatedIds.length > 0) {
      qb.where("resource.relatedId IN (:...ids)", { ids: filter.relatedIds });
    }
    const list = await qb.getMany();
    if (list.length) await this.repo.delete(list.map((x) => x.id));
  }

  async findWithRelations(id: string, relations?: string[]): Promise<ResourceDto> {
    const resource = await this.repo.findOne({
      where: { id },
      relations: relations ?? ["relatedEntity", "anotherEntity"],
    });
    if (!resource) throw new Error("Resource not found");
    return ModuleDto.importEntity(resource);
  }

  async updateRepeatId(id: string, repeatId: string): Promise<void> {
    await this.repo.update(id, { repeatId });
  }

  async softDeleteByRelatedIds(relatedIds: string[]): Promise<void> {
    if (!relatedIds || relatedIds.length === 0) return;
    const items = await this.repo.find({ where: { relatedId: In(relatedIds) } });
    if (items.length) await this.repo.softRemove(items);
  }

  async findOneByRepeatAndDate(
    repeatId: string,
    date: Date
  ): Promise<ResourceDto | null> {
    const resource = await this.repo.findOne({
      where: { repeatId, planDate: date },
    });
    return resource ? ModuleDto.importEntity(resource) : null;
  }
}
```

## ğŸ¯ è®¾è®¡åŸåˆ™

### 1. è½»é‡çº§æŸ¥è¯¢ä¼˜åŒ–
- ä¼˜å…ˆè€ƒè™‘æœ¬åœ°å­˜å‚¨çš„æ€§èƒ½ç‰¹ç‚¹
- ç®€åŒ–å¤æ‚æŸ¥è¯¢é€»è¾‘
- ä¼˜åŒ–æ•°æ®åŠ è½½ç­–ç•¥

### 2. ç¦»çº¿æ•°æ®æ”¯æŒ
- æ”¯æŒæœ¬åœ°æ•°æ®ç¼“å­˜
- å¤„ç†æ•°æ®åŒæ­¥é€»è¾‘
- å®ç°å†²çªè§£å†³æœºåˆ¶

### 3. èµ„æºç®¡ç†ä¼˜åŒ–
- æ§åˆ¶å†…å­˜ä½¿ç”¨
- å®ç°æ•°æ®åˆ†é¡µåŠ è½½
- ä¼˜åŒ–å¤§æ•°æ®é›†å¤„ç†

## ğŸ“ æ ¸å¿ƒæ–¹æ³•å®ç°

### æŸ¥è¯¢æ¡ä»¶æ„å»ºå™¨
```typescript
private buildQuery(filter: ModuleListFilterDto) {
  const qb = this.repo
    .createQueryBuilder("resource")
    .leftJoinAndSelect("resource.relatedEntity", "relatedEntity");

  // çŠ¶æ€æ¡ä»¶
  if (filter.status !== undefined) {
    qb.andWhere("resource.status = :status", { status: filter.status });
  }

  // é‡è¦ç¨‹åº¦æ¡ä»¶
  if (filter.importance !== undefined) {
    qb.andWhere("resource.importance = :importance", {
      importance: filter.importance,
    });
  }

  // å…³é”®è¯æœç´¢
  if (filter.keyword) {
    qb.andWhere("resource.name LIKE :kw", { kw: `%${filter.keyword}%` });
  }

  // æ—¥æœŸèŒƒå›´æ¡ä»¶
  if (filter.planDateStart) {
    qb.andWhere("resource.planDate >= :ds", { ds: filter.planDateStart });
  }
  if (filter.planDateEnd) {
    qb.andWhere("resource.planDate <= :de", { de: filter.planDateEnd });
  }

  return qb;
}
```

### åˆ›å»ºæ–¹æ³•å®ç°
```typescript
async create(createDto: CreateModuleDto): Promise<ResourceDto> {
  // 1. ä½¿ç”¨ DTO åˆ›å»ºå®ä½“
  const entity = this.repo.create({
    name: createDto.name,
    description: createDto.description,
    status: createDto.status ?? ModuleStatus.ACTIVE,
    importance: createDto.importance,
    urgency: createDto.urgency,
    tags: createDto.tags,
    planDate: createDto.planDate,
    planStartAt: createDto.planStartAt,
    planEndAt: createDto.planEndAt,
    relatedId: createDto.relatedId,
    type: ResourceType.MANUAL,
  });

  // 2. ä¿å­˜åˆ°æ•°æ®åº“
  const saved = await this.repo.save(entity);

  // 3. è½¬æ¢ä¸º DTO è¿”å›
  return ModuleDto.importEntity(saved);
}
```

### åˆ†é¡µæŸ¥è¯¢å®ç°
```typescript
async page(filter: ModulePageFiltersDto): Promise<{
  list: ResourceDto[];
  total: number;
  pageNum: number;
  pageSize: number;
}> {
  const { pageNum = 1, pageSize = 10 } = filter;

  // 1. æ„å»ºæŸ¥è¯¢
  const qb = this.buildQuery(filter);

  // 2. æ‰§è¡Œåˆ†é¡µæŸ¥è¯¢
  const [list, total] = await qb
    .skip((pageNum - 1) * pageSize)
    .take(pageSize)
    .orderBy("resource.createdAt", "DESC")
    .getManyAndCount();

  // 3. è½¬æ¢ä¸º DTO è¿”å›
  return {
    list: list.map((item) => ModuleDto.importEntity(item)),
    total,
    pageNum,
    pageSize,
  };
}
```

### æ‰¹é‡æ›´æ–°å®ç°
```typescript
async batchUpdate(
  includeIds: string[],
  updateDto: UpdateModuleDto
): Promise<ResourceDto[]> {
  // 1. æ‰¹é‡æ›´æ–°
  await this.repo.update(includeIds, updateDto);

  // 2. é‡æ–°æŸ¥è¯¢æ›´æ–°åçš„æ•°æ®
  const qb = this.repo
    .createQueryBuilder("resource")
    .leftJoinAndSelect("resource.relatedEntity", "relatedEntity");

  const list = await qb
    .where("resource.id IN (:...ids)", { ids: includeIds })
    .getMany();

  // 3. è½¬æ¢ä¸º DTO è¿”å›
  return list.map((item) => ModuleDto.importEntity(item));
}
```

## ğŸ”§ é«˜çº§åŠŸèƒ½å®ç°

### å…³è”æŸ¥è¯¢å¤„ç†
```typescript
// æ”¯æŒåŠ¨æ€å…³è”åŠ è½½
async findWithRelations(id: string, relations?: string[]): Promise<ResourceDto> {
  const resource = await this.repo.findOne({
    where: { id },
    relations: relations ?? ["relatedEntity", "anotherEntity"],
  });

  if (!resource) {
    throw new Error("Resource not found");
  }

  return ModuleDto.importEntity(resource);
}
```

### è½¯åˆ é™¤å®ç°
```typescript
async softDeleteByRelatedIds(relatedIds: string[]): Promise<void> {
  if (!relatedIds || relatedIds.length === 0) return;

  // 1. æŸ¥æ‰¾éœ€è¦åˆ é™¤çš„è®°å½•
  const items = await this.repo.find({
    where: { relatedId: In(relatedIds) }
  });

  // 2. æ‰§è¡Œè½¯åˆ é™¤
  if (items.length) {
    await this.repo.softRemove(items);
  }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. æŸ¥è¯¢ä¼˜åŒ–
```typescript
// ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
const qb = this.repo
  .createQueryBuilder("resource")
  .where("resource.status = :status", { status })
  .andWhere("resource.planDate BETWEEN :start AND :end", { start, end })
  .orderBy("resource.createdAt", "DESC");
```

### 2. æ‰¹é‡æ“ä½œä¼˜åŒ–
```typescript
// ä½¿ç”¨äº‹åŠ¡ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
await this.repo.manager.transaction(async (manager) => {
  await manager.update(Resource, includeIds, updateDto);
  await manager.delete(Resource, { relatedId: null });
});
```

### 3. å†…å­˜ç®¡ç†
```typescript
// åˆ†æ‰¹å¤„ç†å¤§æ•°æ®é›†
const batchSize = 100;
for (let i = 0; i < includeIds.length; i += batchSize) {
  const batch = includeIds.slice(i, i + batchSize);
  await this.repo.update(batch, updateDto);
}
```

## âœ… æ£€æŸ¥æ¸…å•

åœ¨å®ç° Desktop Repository æ—¶ï¼Œè¯·ç¡®è®¤ï¼š

### åŸºç¡€ç»“æ„
- [ ] æ–‡ä»¶è·¯å¾„ç¬¦åˆè§„èŒƒ (`apps/desktop/src/database/{module}/{module}.repository.ts`)
- [ ] æ­£ç¡®å¯¼å…¥ Business Interface å’Œç±»å‹
- [ ] å®ç°äº†æ‰€æœ‰ Interface å®šä¹‰çš„æ–¹æ³•

### å®ç°è§„èŒƒ
- [ ] ä½¿ç”¨ TypeORM Repository æ¨¡å¼
- [ ] æ­£ç¡®å®ç°æŸ¥è¯¢æ¡ä»¶æ„å»ºå™¨
- [ ] å®ç°äº†åˆ†é¡µæŸ¥è¯¢é€»è¾‘
- [ ] æ­£ç¡®å¤„ç†æ‰¹é‡æ“ä½œ

### æ•°æ®æ˜ å°„
- [ ] åœ¨ DTO ä¸­è¿›è¡Œ Entity/DTO è½¬æ¢
- [ ] æ­£ç¡®å¤„ç†å…³è”å…³ç³»
- [ ] å®ç°è½¯åˆ é™¤é€»è¾‘

### æ€§èƒ½ä¼˜åŒ–
- [ ] ä¼˜åŒ–æŸ¥è¯¢è¯­å¥
- [ ] åˆç†ä½¿ç”¨ç´¢å¼•
- [ ] æ§åˆ¶å†…å­˜ä½¿ç”¨
- [ ] å¤„ç†å¤§æ•°æ®é›†

### é”™è¯¯å¤„ç†
- [ ] å®ç°å¼‚å¸¸å¤„ç†æœºåˆ¶
- [ ] æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
- [ ] ç¡®ä¿æ•°æ®ä¸€è‡´æ€§

## ğŸ“ å®Œæ•´ç¤ºä¾‹

```typescript
// apps/desktop/src/database/resource/resource.repository.ts

import { Repository, In } from "typeorm";
import { AppDataSource } from "../../database.config";
import {
  CreateModuleDto,
  UpdateModuleDto,
  ModulePageFiltersDto,
  ModuleListFilterDto,
  ResourceDto,
  ModuleMapper,
  Resource,
} from "@life-toolkit/business-server";
import { ModuleStatus, ResourceType } from "@life-toolkit/enum";

export class ModuleRepository {
  private repo: Repository<Module> = AppDataSource.getRepository(Resource);

  private buildQuery(filter: ModuleListFilterDto) {
    const qb = this.repo
      .createQueryBuilder("resource")
      .leftJoinAndSelect("resource.relatedEntity", "relatedEntity")
      .leftJoinAndSelect("resource.anotherEntity", "anotherEntity");

    if (filter.status !== undefined) {
      qb.andWhere("resource.status = :status", { status: filter.status });
    }
    if (filter.importance !== undefined) {
      qb.andWhere("resource.importance = :importance", {
        importance: filter.importance,
      });
    }
    if (filter.urgency !== undefined) {
      qb.andWhere("resource.urgency = :urgency", { urgency: filter.urgency });
    }
    if (filter.relatedId) {
      qb.andWhere("resource.relatedId = :relatedId", { relatedId: filter.relatedId });
    }
    if (filter.keyword) {
      qb.andWhere("resource.name LIKE :kw", { kw: `%${filter.keyword}%` });
    }
    if (filter.planDateStart) {
      qb.andWhere("resource.planDate >= :ds", { ds: filter.planDateStart });
    }
    if (filter.planDateEnd) {
      qb.andWhere("resource.planDate <= :de", { de: filter.planDateEnd });
    }
    if (filter.doneDateStart) {
      qb.andWhere("resource.doneAt >= :dds", { dds: filter.doneDateStart });
    }
    if (filter.doneDateEnd) {
      qb.andWhere("resource.doneAt <= :dde", { dde: filter.doneDateEnd });
    }

    return qb;
  }

  async create(createDto: CreateModuleDto): Promise<ResourceDto> {
    const entity = this.repo.create({
      name: createDto.name,
      description: createDto.description,
      status: createDto.status ?? ModuleStatus.ACTIVE,
      importance: createDto.importance,
      urgency: createDto.urgency,
      tags: createDto.tags,
      planDate: createDto.planDate,
      planStartAt: createDto.planStartAt,
      planEndAt: createDto.planEndAt,
      relatedId: createDto.relatedId,
      type: ResourceType.MANUAL,
    });
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async createWithExtras(
    createDto: CreateModuleDto,
    extras: Partial<Resource>
  ): Promise<ResourceDto> {
    const entity = this.repo.create({
      name: createDto.name,
      description: createDto.description,
      status: createDto.status ?? ModuleStatus.ACTIVE,
      importance: createDto.importance,
      urgency: createDto.urgency,
      tags: createDto.tags,
      planDate: createDto.planDate,
      planStartAt: createDto.planStartAt,
      planEndAt: createDto.planEndAt,
      relatedId: createDto.relatedId,
      type: ResourceType.MANUAL,
      ...extras,
    });
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async findByFilter(filter: ModuleListFilterDto): Promise<ResourceDto[]> {
    const qb = this.buildQuery(filter);
    const list = await qb.orderBy("resource.createdAt", "DESC").getMany();
    return list.map((item) => ModuleDto.importEntity(item));
  }

  async page(filter: ModulePageFiltersDto): Promise<{
    list: ResourceDto[];
    total: number;
    pageNum: number;
    pageSize: number;
  }> {
    const { pageNum = 1, pageSize = 10 } = filter;
    const qb = this.buildQuery(filter);

    const [list, total] = await qb
      .skip((pageNum - 1) * pageSize)
      .take(pageSize)
      .orderBy("resource.createdAt", "DESC")
      .getManyAndCount();

    return {
      list: list.map((item) => ModuleDto.importEntity(item)),
      total,
      pageNum,
      pageSize,
    };
  }

  async update(id: string, updateDto: UpdateModuleDto): Promise<ResourceDto> {
    const entity = await this.repo.findOne({ where: { id } });
    if (!entity) throw new Error("Resource not found");

    updateDto.exportUpdateEntity(entity);
    const saved = await this.repo.save(entity);
    return ModuleDto.importEntity(saved);
  }

  async batchUpdate(
    includeIds: string[],
    updateDto: UpdateModuleDto
  ): Promise<ResourceDto[]> {
    await this.repo.update(includeIds, updateDto);
    const qb = this.repo
      .createQueryBuilder("resource")
      .leftJoinAndSelect("resource.relatedEntity", "relatedEntity")
      .leftJoinAndSelect("resource.anotherEntity", "anotherEntity");

    const list = await qb
      .where("resource.id IN (:...ids)", { ids: includeIds })
      .getMany();

    return list.map((item) => ModuleDto.importEntity(item));
  }

  async delete(id: string): Promise<boolean> {
    await this.repo.delete(id);
    return true;
  }

  async deleteByFilter(filter: ModulePageFiltersDto): Promise<void> {
    const qb = this.repo.createQueryBuilder("resource");
    if (filter.relatedIds && filter.relatedIds.length > 0) {
      qb.where("resource.relatedId IN (:...ids)", { ids: filter.relatedIds });
    }
    const list = await qb.getMany();
    if (list.length) await this.repo.delete(list.map((x) => x.id));
  }

  async findWithRelations(id: string, relations?: string[]): Promise<ResourceDto> {
    const resource = await this.repo.findOne({
      where: { id },
      relations: relations ?? ["relatedEntity", "anotherEntity"],
    });
    if (!resource) throw new Error("Resource not found");
    return ModuleDto.importEntity(resource);
  }

  async updateRepeatId(id: string, repeatId: string): Promise<void> {
    await this.repo.update(id, { repeatId });
  }

  async softDeleteByRelatedIds(relatedIds: string[]): Promise<void> {
    if (!relatedIds || relatedIds.length === 0) return;
    const items = await this.repo.find({ where: { relatedId: In(relatedIds) } });
    if (items.length) await this.repo.softRemove(items);
  }

  async findOneByRepeatAndDate(
    repeatId: string,
    date: Date
  ): Promise<ResourceDto | null> {
    const resource = await this.repo.findOne({
      where: { repeatId, planDate: date },
    });
    return resource ? ModuleDto.importEntity(resource) : null;
  }
}
```

## ğŸ“‹ ç›¸å…³è§„èŒƒ

- [Business Repository Interface è§„èŒƒ](./repository-business.mdc) - Interface å®šä¹‰è§„èŒƒ
- [Server Repository è§„èŒƒ](./repository-server.mdc) - Server å±‚å®ç°è§„èŒƒ
- [Entity è§„èŒƒ](../entity.mdc) - æ•°æ®å®ä½“å®šä¹‰è§„èŒƒ
- [DTO è§„èŒƒ](../dto.mdc) - æ•°æ®ä¼ è¾“å¯¹è±¡è§„èŒƒ
