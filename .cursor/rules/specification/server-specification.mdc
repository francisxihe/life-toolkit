---
description: éœ€è¦è°ƒæ•´æœåŠ¡ç«¯ä»£ç æ—¶
globs: 
alwaysApply: false
---
## Life Toolkit Server æ¶æ„ä»£ç ç”Ÿæˆè§„åˆ™

### ğŸ“‹ æ ¸å¿ƒå­—æ®µç±»å‹å®šä¹‰

```typescript
// æ”¯æŒçš„å­—æ®µç±»å‹
type FieldType =
  | "string"
  | "number"
  | "boolean"
  | "Date"
  | "enum"
  | "object"
  | "array";

// å­—æ®µä¿¡æ¯ç»“æ„
interface FieldInfo {
  entityName: string; // å®ä½“åç§°ï¼ˆæ”¯æŒåµŒå¥—è·¯å¾„ï¼Œå¦‚ user/profileï¼‰
  fieldName: string; // å­—æ®µåç§°
  fieldType: FieldType; // å­—æ®µç±»å‹
  isNullable: boolean; // æ˜¯å¦å¯ç©º
  description: string; // å­—æ®µæè¿°
  enumValues?: string[]; // æšä¸¾å€¼ï¼ˆä»…å½“ç±»å‹ä¸º enum æ—¶ï¼‰
}
```

### ğŸ—ï¸ é¡¹ç›®ç»“æ„çº¦å®š

```
apps/server/src/business/{domain}/{module}/
â”œâ”€â”€ entities/                          # å®ä½“å±‚
â”‚   â”œâ”€â”€ {entity}.entity.ts            # TypeORM å®ä½“æ–‡ä»¶
â”‚   â”œâ”€â”€ enum.ts                       # æšä¸¾å®šä¹‰
â”‚   â””â”€â”€ index.ts                      # å¯¼å‡ºæ–‡ä»¶
â”œâ”€â”€ dto/                              # æ•°æ®ä¼ è¾“å¯¹è±¡å±‚
â”‚   â”œâ”€â”€ {entity}-model.dto.ts         # åŸºç¡€æ¨¡å‹ DTO
â”‚   â”œâ”€â”€ {entity}-form.dto.ts          # è¡¨å•æ“ä½œ DTO
â”‚   â”œâ”€â”€ {entity}-filter.dto.ts        # è¿‡æ»¤æŸ¥è¯¢ DTO
â”‚   â””â”€â”€ index.ts                      # å¯¼å‡ºæ–‡ä»¶
â”œâ”€â”€ mappers/                          # å¯¹è±¡æ˜ å°„å±‚
â”‚   â”œâ”€â”€ {entity}.mapper.ts            # å¯¹è±¡æ˜ å°„æ–‡ä»¶
â”‚   â””â”€â”€ index.ts                      # å¯¼å‡ºæ–‡ä»¶
â”œâ”€â”€ {module}.controller.ts            # æ§åˆ¶å™¨å±‚
â”œâ”€â”€ {module}.service.ts               # ä¸šåŠ¡æœåŠ¡å±‚
â”œâ”€â”€ {module}.repository.ts            # æ•°æ®è®¿é—®å±‚ï¼ˆå¯é€‰ï¼‰
â”œâ”€â”€ {module}-{feature}.service.ts     # ç‰¹æ€§æœåŠ¡å±‚ï¼ˆå¯é€‰ï¼‰
â””â”€â”€ {module}.module.ts                # æ¨¡å—å®šä¹‰

packages/vo/{domain}/
â””â”€â”€ {entity}-model.vo.ts              # å€¼å¯¹è±¡æ¥å£æ–‡ä»¶
```

### ğŸ”„ æœåŠ¡åˆ†å±‚æ¶æ„

#### åˆ†å±‚èŒè´£å®šä¹‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ§åˆ¶å™¨å±‚                   â”‚
â”‚        {Module}Controller           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ â€¢ è·¯ç”±å¤„ç†                      â”‚ â”‚
â”‚  â”‚ â€¢ å‚æ•°éªŒè¯                      â”‚ â”‚
â”‚  â”‚ â€¢ VO â†” DTO è½¬æ¢                â”‚ â”‚
â”‚  â”‚ â€¢ å“åº”æ ¼å¼åŒ–                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¸šåŠ¡æœåŠ¡å±‚                 â”‚
â”‚         {Module}Service             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ â€¢ ä¸šåŠ¡é€»è¾‘ç¼–æ’                  â”‚ â”‚
â”‚  â”‚ â€¢ äº‹åŠ¡ç®¡ç†                      â”‚ â”‚
â”‚  â”‚ â€¢ è·¨æ¨¡å—è°ƒç”¨                    â”‚ â”‚
â”‚  â”‚ â€¢ å¤æ‚ä¸šåŠ¡è§„åˆ™                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ•°æ®è®¿é—®å±‚                 â”‚
â”‚       {Module}Repository            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ â€¢ åŸºç¡€ CRUD æ“ä½œ                â”‚ â”‚
â”‚  â”‚ â€¢ æ•°æ®åº“æŸ¥è¯¢                    â”‚ â”‚
â”‚  â”‚ â€¢ Entity â†” DTO è½¬æ¢            â”‚ â”‚
â”‚  â”‚ â€¢ æ•°æ®æŒä¹…åŒ–                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ•°æ®å­˜å‚¨å±‚                 â”‚
â”‚         TypeORM Entity              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ â€¢ æ•°æ®æ¨¡å‹å®šä¹‰                  â”‚ â”‚
â”‚  â”‚ â€¢ å…³ç³»æ˜ å°„                      â”‚ â”‚
â”‚  â”‚ â€¢ æ•°æ®éªŒè¯                      â”‚ â”‚
â”‚  â”‚ â€¢ æ•°æ®åº“çº¦æŸ                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ•°æ®è®¿é—®å±‚ ({module}.repository.ts)

```typescript
@Injectable()
export class {Module}Repository {
  constructor(
    @InjectRepository({Entity})
    private readonly {entity}Repository: Repository<{Entity}>,
  ) {}

  // åŸºç¡€ CRUD æ“ä½œ
  async create(create{Entity}Dto: Create{Entity}Dto): Promise<{Entity}Dto> {
    const entity = this.{entity}Repository.create(create{Entity}Dto);
    const savedEntity = await this.{entity}Repository.save(entity);
    return {Entity}Mapper.entityToDto(savedEntity);
  }

  async findById(id: string, relations?: string[]): Promise<{Entity}Dto> {
    const entity = await this.{entity}Repository.findOne({
      where: { id },
      relations,
    });
    if (!entity) {
      throw new NotFoundException(`{Entity}ä¸å­˜åœ¨ï¼ŒID: ${id}`);
    }
    return {Entity}Mapper.entityToDto(entity);
  }

  async findAll(filter: {Entity}ListFilterDto): Promise<{Entity}Dto[]> {
    const query = this.buildQuery(filter);
    const entities = await query.getMany();
    return entities.map(entity => {Entity}Mapper.entityToDto(entity));
  }

  async page(
    filter: {Entity}PageFilterDto
  ): Promise<{ list: {Entity}Dto[]; total: number }> {
    const { pageNum = 1, pageSize = 10 } = filter;
    const skip = (pageNum - 1) * pageSize;

    const query = this.buildQuery(filter);
    const [entities, total] = await query
      .skip(skip)
      .take(pageSize)
      .getManyAndCount();

    return {
      list: entities.map(entity => {Entity}Mapper.entityToDto(entity)),
      total,
    };
  }

  async update(id: string, update{Entity}Dto: Update{Entity}Dto): Promise<{Entity}Dto> {
    const entity = await this.{entity}Repository.findOne({ where: { id } });
    if (!entity) {
      throw new NotFoundException(`{Entity}ä¸å­˜åœ¨ï¼ŒID: ${id}`);
    }

    Object.assign(entity, update{Entity}Dto);
    const savedEntity = await this.{entity}Repository.save(entity);
    return {Entity}Mapper.entityToDto(savedEntity);
  }

  async delete(id: string): Promise<void> {
    const entity = await this.{entity}Repository.findOne({ where: { id } });
    if (!entity) {
      throw new NotFoundException(`{Entity}ä¸å­˜åœ¨ï¼ŒID: ${id}`);
    }
    await this.{entity}Repository.remove(entity);
  }

  async softDelete(id: string): Promise<void> {
    const result = await this.{entity}Repository.softDelete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`{Entity}ä¸å­˜åœ¨ï¼ŒID: ${id}`);
    }
  }

  async batchUpdate(ids: string[], updateData: Partial<{Entity}>): Promise<void> {
    await this.{entity}Repository.update(
      { id: In(ids) },
      updateData
    );
  }

  // æ„å»ºæŸ¥è¯¢æ¡ä»¶çš„ç§æœ‰æ–¹æ³•
  private buildQuery(filter: {Entity}ListFilterDto) {
    let query = this.{entity}Repository.createQueryBuilder("{entity}");

    // çŠ¶æ€è¿‡æ»¤
    if (filter.status && filter.status.length > 0) {
      query = query.andWhere("{entity}.status IN (:...status)", { status: filter.status });
    }

    // å…³é”®è¯æœç´¢
    if (filter.keyword) {
      query = query.andWhere(
        "({entity}.name LIKE :keyword OR {entity}.description LIKE :keyword)",
        { keyword: `%${filter.keyword}%` }
      );
    }

    // æ—¥æœŸèŒƒå›´è¿‡æ»¤
    if (filter.dateStart) {
      query = query.andWhere("{entity}.createdAt >= :dateStart", { dateStart: filter.dateStart });
    }
    if (filter.dateEnd) {
      query = query.andWhere("{entity}.createdAt <= :dateEnd", { dateEnd: filter.dateEnd });
    }

    return query.orderBy("{entity}.updatedAt", "DESC");
  }
}
```

#### ä¸šåŠ¡æœåŠ¡å±‚ ({module}.service.ts)

```typescript
@Injectable()
export class {Module}Service {
  constructor(
    private readonly {module}Repository: {Module}Repository,
    // å…¶ä»–ä¸šåŠ¡æœåŠ¡ä¾èµ–
  ) {}

  // ä¸šåŠ¡é€»è¾‘ç¼–æ’
  async create(create{Entity}Dto: Create{Entity}Dto): Promise<{Entity}Dto> {
    // ä¸šåŠ¡éªŒè¯
    await this.validateBusinessRules(create{Entity}Dto);

    // æ•°æ®å¤„ç†
    const processedDto = await this.processCreateData(create{Entity}Dto);

    // è°ƒç”¨æ•°æ®è®¿é—®å±‚
    const result = await this.{module}Repository.create(processedDto);

    // åç½®å¤„ç†ï¼ˆå¦‚å‘é€é€šçŸ¥ã€æ›´æ–°ç¼“å­˜ç­‰ï¼‰
    await this.afterCreate(result);

    return result;
  }

  async findAll(filter: {Entity}ListFilterDto): Promise<{Entity}Dto[]> {
    // æƒé™æ£€æŸ¥
    await this.checkPermission(filter);

    return await this.{module}Repository.findAll(filter);
  }

  async page(filter: {Entity}PageFilterDto): Promise<{ list: {Entity}Dto[]; total: number }> {
    // æƒé™æ£€æŸ¥
    await this.checkPermission(filter);

    return await this.{module}Repository.page(filter);
  }

  async findById(id: string): Promise<{Entity}Dto> {
    return await this.{module}Repository.findById(id);
  }

  async update(id: string, update{Entity}Dto: Update{Entity}Dto): Promise<{Entity}Dto> {
    // ä¸šåŠ¡éªŒè¯
    await this.validateUpdateRules(id, update{Entity}Dto);

    // æ•°æ®å¤„ç†
    const processedDto = await this.processUpdateData(update{Entity}Dto);

    // è°ƒç”¨æ•°æ®è®¿é—®å±‚
    const result = await this.{module}Repository.update(id, processedDto);

    // åç½®å¤„ç†
    await this.afterUpdate(result);

    return result;
  }

  async delete(id: string): Promise<void> {
    // åˆ é™¤å‰æ£€æŸ¥
    await this.validateDelete(id);

    await this.{module}Repository.delete(id);

    // åç½®å¤„ç†
    await this.afterDelete(id);
  }

  // çŠ¶æ€æ“ä½œï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰
  async done(id: string): Promise<boolean> {
    const entity = await this.{module}Repository.findById(id);

    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (!this.canMarkAsDone(entity)) {
      throw new BadRequestException("å½“å‰çŠ¶æ€ä¸å…è®¸æ ‡è®°ä¸ºå®Œæˆ");
    }

    await this.{module}Repository.update(id, {
      status: {Entity}Status.DONE,
      doneAt: new Date(),
    });

    return true;
  }

  async abandon(id: string): Promise<boolean> {
    const entity = await this.{module}Repository.findById(id);

    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (!this.canAbandon(entity)) {
      throw new BadRequestException("å½“å‰çŠ¶æ€ä¸å…è®¸æ”¾å¼ƒ");
    }

    await this.{module}Repository.update(id, {
      status: {Entity}Status.ABANDONED,
      abandonedAt: new Date(),
    });

    return true;
  }

  async restore(id: string): Promise<boolean> {
    const entity = await this.{module}Repository.findById(id);

    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (!this.canRestore(entity)) {
      throw new BadRequestException("å½“å‰çŠ¶æ€ä¸å…è®¸æ¢å¤");
    }

    await this.{module}Repository.update(id, {
      status: {Entity}Status.ACTIVE,
      restoredAt: new Date(),
    });

    return true;
  }

  // æ‰¹é‡æ“ä½œ
  async batchDone(params: OperationByIdListDto): Promise<void> {
    // æ‰¹é‡éªŒè¯
    await this.validateBatchOperation(params.idList, 'done');

    await this.{module}Repository.batchUpdate(params.idList, {
      status: {Entity}Status.DONE,
      doneAt: new Date(),
    });
  }

  // ç§æœ‰ä¸šåŠ¡æ–¹æ³•
  private async validateBusinessRules(dto: Create{Entity}Dto): Promise<void> {
    // å®ç°ä¸šåŠ¡è§„åˆ™éªŒè¯
  }

  private async processCreateData(dto: Create{Entity}Dto): Promise<Create{Entity}Dto> {
    // å®ç°æ•°æ®é¢„å¤„ç†
    return dto;
  }

  private async afterCreate(result: {Entity}Dto): Promise<void> {
    // å®ç°åˆ›å»ºåå¤„ç†
  }

  private canMarkAsDone(entity: {Entity}Dto): boolean {
    // å®ç°ä¸šåŠ¡è§„åˆ™åˆ¤æ–­
    return true;
  }

  private async checkPermission(filter: any): Promise<void> {
    // å®ç°æƒé™æ£€æŸ¥
  }
}
```

#### ç‰¹æ€§æœåŠ¡å±‚ ({module}-feature.service.ts)

```typescript
// ç¤ºä¾‹ï¼štodo-status.service.ts
@Injectable()
export class {Module}StatusService {
  constructor(
    private readonly {module}Repository: {Module}Repository,
  ) {}

  async batchDone(params: OperationByIdListDto): Promise<void> {
    // ä¸“é—¨å¤„ç†çŠ¶æ€ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
    await this.{module}Repository.batchUpdate(params.idList, {
      status: {Entity}Status.DONE,
      doneAt: new Date(),
    });
  }

  async done(id: string): Promise<void> {
    await this.{module}Repository.update(id, {
      status: {Entity}Status.DONE,
      doneAt: new Date(),
    });
  }

  async abandon(id: string): Promise<void> {
    await this.{module}Repository.update(id, {
      status: {Entity}Status.ABANDONED,
      abandonedAt: new Date(),
    });
  }

  async restore(id: string): Promise<void> {
    await this.{module}Repository.update(id, {
      status: {Entity}Status.ACTIVE,
    });
  }
}
```

### ğŸ”§ Entity æ–‡ä»¶æ›´æ–°è§„åˆ™

#### TypeORM è£…é¥°å™¨æ˜ å°„

```typescript
const TYPE_DECORATORS: Record<FieldType, string> = {
  string: "@Column('varchar')",
  number: "@Column('int')",
  boolean: "@Column('boolean')",
  Date: '@Column("datetime")',
  enum: '@Column({ type: "enum", enum: {EnumType} })',
  object: '@Column("json")',
  array: '@Column("simple-array")',
};

const VALIDATOR_DECORATORS: Record<FieldType, string> = {
  string: "@IsString()",
  number: "@IsNumber()",
  boolean: "@IsBoolean()",
  Date: "@IsISO8601()",
  enum: "@IsEnum({EnumType})",
  object: "@IsObject()",
  array: "@IsArray()",
};
```

#### Entity å­—æ®µç”Ÿæˆæ¨¡æ¿

```typescript
// å­—æ®µå®šä¹‰æ¨¡æ¿
/** {description} */
{typeDecorator}
{nullableDecorator}  // @IsOptional() å¦‚æœ isNullable ä¸º true
{validatorDecorator}
{fieldName}{nullableSymbol}: {fieldType};

// ç¤ºä¾‹ï¼š
/** ç”¨æˆ·çŠ¶æ€ */
@Column({ type: "enum", enum: UserStatus })
@IsEnum(UserStatus)
status: UserStatus;
```

### ğŸ“ DTO æ–‡ä»¶æ›´æ–°è§„åˆ™

#### DTO ç±»å‘½åçº¦å®š

- `{Entity}Dto` - åŸºç¡€æ•°æ®ä¼ è¾“å¯¹è±¡ï¼ˆåŒ…å«æ‰€æœ‰å­—æ®µï¼‰
- `{Entity}ModelDto` - æ¨¡å‹æ•°æ®ä¼ è¾“å¯¹è±¡ï¼ˆæ’é™¤å…³è”å­—æ®µï¼‰
- `Create{Entity}Dto` - åˆ›å»ºæ“ä½œ DTO
- `Update{Entity}Dto` - æ›´æ–°æ“ä½œ DTO
- `{Entity}ListFilterDto` - åˆ—è¡¨è¿‡æ»¤å™¨ DTO
- `{Entity}PageFilterDto` - åˆ†é¡µè¿‡æ»¤å™¨ DTO

#### DTO æ–‡ä»¶ç»“æ„è§„èŒƒ

```typescript
// {entity}-model.dto.ts
import { BaseModelDto } from "@/base/base-model.dto";
import { IntersectionType, OmitType } from "@nestjs/mapped-types";
import { {Entity} } from "../entities";

export class {Entity}Dto extends IntersectionType(
  BaseModelDto,
  OmitType({Entity}, ["relationField"] as const)
) {
  relationField?: RelatedDto;
}

export class {Entity}ModelDto extends OmitType({Entity}Dto, [
  "relationField",
] as const) {}
```

#### DTO å­—æ®µç”Ÿæˆæ¨¡æ¿

```typescript
/** {description} */
{fieldName}{nullableSymbol}: {fieldType};
```

### ğŸ¯ VO æ¥å£æ›´æ–°è§„åˆ™

#### VO æ¥å£å‘½åçº¦å®š

- `{Entity}Vo` - åŸºç¡€å€¼å¯¹è±¡æ¥å£
- `{Entity}ModelVo` - æ¨¡å‹å€¼å¯¹è±¡æ¥å£
- `Create{Entity}Vo` - åˆ›å»ºæ“ä½œå€¼å¯¹è±¡
- `Update{Entity}Vo` - æ›´æ–°æ“ä½œå€¼å¯¹è±¡

#### VO å­—æ®µç”Ÿæˆæ¨¡æ¿

```typescript
/** {description} */
{fieldName}{nullableSymbol}: {fieldType};
```

### ğŸ”„ Mapper æ–‡ä»¶æ›´æ–°è§„åˆ™

#### Mapper ç±»ç»“æ„è§„èŒƒ

```typescript
export class {Entity}Mapper {
  // Entity è½¬ DTO
  static entityToDto(entity: {Entity}): {Entity}Dto {
    const dto = new {Entity}Dto();
    // å­—æ®µæ˜ å°„
    return dto;
  }

  // DTO è½¬ VO
  static dtoToVo(dto: {Entity}Dto): {Entity}.{Entity}Vo {
    return {
      // å­—æ®µæ˜ å°„
    };
  }

  // VO è½¬åˆ›å»º DTO
  static voToCreateDto(vo: {Entity}.Create{Entity}Vo): Create{Entity}Dto {
    const dto = new Create{Entity}Dto();
    // å­—æ®µæ˜ å°„
    return dto;
  }

  // VO è½¬æ›´æ–° DTO
  static voToUpdateDto(vo: {Entity}.Update{Entity}Vo): Update{Entity}Dto {
    const dto = new Update{Entity}Dto();
    // å­—æ®µæ˜ å°„
    return dto;
  }

  // DTO åˆ—è¡¨è½¬ VO åˆ—è¡¨
  static dtoToListVo(dtos: {Entity}Dto[]): {Entity}.{Entity}ListVo {
    return {
      list: dtos.map(dto => this.dtoToVo(dto)),
    };
  }

  // DTO åˆ†é¡µè½¬ VO åˆ†é¡µ
  static dtoToPageVo(
    dtos: {Entity}Dto[],
    total: number,
    pageNum: number,
    pageSize: number
  ): {Entity}.{Entity}PageVo {
    return {
      list: dtos.map(dto => this.dtoToVo(dto)),
      total,
      pageNum,
      pageSize,
    };
  }
}
```

#### Mapper æ–¹æ³•æ›´æ–°ç‚¹

1. **entityToDto æ–¹æ³•** - å®ä½“è½¬ DTO

```typescript
dto.{fieldName} = entity.{fieldName};
```

2. **dtoToVo æ–¹æ³•** - DTO è½¬å€¼å¯¹è±¡

```typescript
{fieldName}: dto.{fieldName},
```

### ğŸ® Controller æ–‡ä»¶è§„èŒƒ

#### Controller ç±»ç»“æ„è§„èŒƒ

```typescript
@Controller("{module}")
export class {Module}Controller {
  constructor(private readonly {module}Service: {Module}Service) {}

  // æ ‡å‡† CRUD æ“ä½œ
  @Post("create")
  @Response()
  async create(@Body() create{Entity}Vo: {Entity}.Create{Entity}Vo) {
    const dto = {Entity}Mapper.voToCreateDto(create{Entity}Vo);
    const result = await this.{module}Service.create(dto);
    return {Entity}Mapper.dtoToVo(result);
  }

  @Put("update/:id")
  @Response()
  async update(
    @Param("id") id: string,
    @Body() update{Entity}Vo: {Entity}.Update{Entity}Vo
  ) {
    const dto = {Entity}Mapper.voToUpdateDto(update{Entity}Vo);
    const result = await this.{module}Service.update(id, dto);
    return {Entity}Mapper.dtoToVo(result);
  }

  @Delete("delete/:id")
  @Response()
  async delete(@Param("id") id: string) {
    return await this.{module}Service.delete(id);
  }

  @Get("detail/:id")
  @Response()
  async findById(@Param("id") id: string) {
    const result = await this.{module}Service.findById(id);
    return {Entity}Mapper.dtoToVo(result);
  }

  @Get("list")
  @Response()
  async list(@Query() filter: {Entity}ListFilterDto) {
    const results = await this.{module}Service.findAll(filter);
    return {Entity}Mapper.dtoToListVo(results);
  }

  @Get("page")
  @Response()
  async page(@Query() filter: {Entity}PageFilterDto) {
    const { list, total } = await this.{module}Service.page(filter);
    return {Entity}Mapper.dtoToPageVo(
      list,
      total,
      filter.pageNum || 1,
      filter.pageSize || 10
    );
  }

  // çŠ¶æ€æ“ä½œ
  @Put("done/:id")
  @Response()
  async done(@Param("id") id: string) {
    const result = await this.{module}Service.done(id);
    return { result };
  }

  @Put("abandon/:id")
  @Response()
  async abandon(@Param("id") id: string) {
    const result = await this.{module}Service.abandon(id);
    return { result };
  }

  @Put("restore/:id")
  @Response()
  async restore(@Param("id") id: string) {
    const result = await this.{module}Service.restore(id);
    return { result };
  }

  // æ‰¹é‡æ“ä½œ
  @Put("batch-done")
  @Response()
  async batchDone(@Body() idList: OperationByIdListVo) {
    return await this.{module}Service.batchDone(
      OperationMapper.voToOperationByIdListDto(idList)
    );
  }
}
```

### âš¡ å­—æ®µç±»å‹å¤„ç†è§„åˆ™

#### å¯ç©ºå­—æ®µå¤„ç†

- å¦‚æœ `isNullable` ä¸º `true`ï¼š
  - TypeScript ç±»å‹æ·»åŠ  `?` ç¬¦å·
  - Entity æ·»åŠ  `@IsOptional()` è£…é¥°å™¨
  - TypeORM Column æ·»åŠ  `{ nullable: true }` é€‰é¡¹

#### æšä¸¾ç±»å‹å¤„ç†

- å½“å­—æ®µç±»å‹ä¸º `enum` æ—¶ï¼š
  - éœ€è¦æä¾› `enumValues` æ•°ç»„
  - ç”Ÿæˆå¯¹åº”çš„æšä¸¾ç±»å‹å®šä¹‰
  - åœ¨è£…é¥°å™¨ä¸­å¼•ç”¨æšä¸¾ç±»å‹

#### æ•°ç»„ç±»å‹å¤„ç†

- ä½¿ç”¨ TypeORM çš„ `simple-array` ç±»å‹
- TypeScript ç±»å‹ä¸º `{baseType}[]`

### ğŸ“ æ–‡ä»¶æ’å…¥ä½ç½®è§„åˆ™

#### Entity æ–‡ä»¶

- åœ¨ç±»çš„æœ€åä¸€ä¸ª `}` ä¹‹å‰æ’å…¥æ–°å­—æ®µ

#### DTO æ–‡ä»¶

- åœ¨æ¯ä¸ª DTO ç±»çš„æœ€åä¸€ä¸ª `}` ä¹‹å‰æ’å…¥æ–°å­—æ®µ

#### VO æ¥å£

- åœ¨æ¯ä¸ªæ¥å£çš„æœ€åä¸€ä¸ª `}` ä¹‹å‰æ’å…¥æ–°å­—æ®µ

#### Mapper æ–‡ä»¶

- åœ¨ `entityToDto` æ–¹æ³•çš„ `return dto;` ä¹‹å‰æ’å…¥æ˜ å°„ä»£ç 
- åœ¨ `dtoToVo` æ–¹æ³•çš„ `return vo;` ä¹‹å‰æ’å…¥æ˜ å°„ä»£ç 

### ğŸ›¡ï¸ é”™è¯¯å¤„ç†è§„åˆ™

1. **å­—æ®µéªŒè¯**

   - å­—æ®µåç§°ä¸èƒ½ä¸ºç©º
   - å­—æ®µæè¿°ä¸èƒ½ä¸ºç©º
   - æšä¸¾ç±»å‹å¿…é¡»æä¾›æšä¸¾å€¼

2. **æ–‡ä»¶æ£€æŸ¥**

   - ç¡®ä¿ç›®æ ‡æ–‡ä»¶å­˜åœ¨
   - å¤‡ä»½é‡è¦æ–‡ä»¶ï¼ˆå»ºè®®ï¼‰

3. **ç±»å‹å®‰å…¨**
   - ä½¿ç”¨ TypeScript ä¸¥æ ¼ç±»å‹æ£€æŸ¥
   - ç¡®ä¿ç”Ÿæˆçš„ä»£ç ç¬¦åˆé¡¹ç›®è§„èŒƒ

### ğŸ¨ ä»£ç é£æ ¼è§„åˆ™

1. **æ³¨é‡Šæ ¼å¼**

   - ä½¿ç”¨ JSDoc é£æ ¼çš„å­—æ®µæè¿°æ³¨é‡Š
   - æ ¼å¼ï¼š`/** {description} */`

2. **ç¼©è¿›å’Œæ ¼å¼**

   - ä½¿ç”¨ 2 ç©ºæ ¼ç¼©è¿›
   - ä¿æŒä¸ç°æœ‰ä»£ç é£æ ¼ä¸€è‡´

3. **å‘½åè§„èŒƒ**
   - å­—æ®µåä½¿ç”¨ camelCase
   - ç±»å‹åä½¿ç”¨ PascalCase
   - æšä¸¾å€¼ä½¿ç”¨ UPPER_CASE æˆ– camelCase

### ğŸ”„ æ¨¡å—ä¾èµ–è§„åˆ™

1. **å¯¼å…¥é¡ºåº**

   - NestJS è£…é¥°å™¨
   - TypeORM ç›¸å…³
   - éªŒè¯è£…é¥°å™¨
   - æœ¬åœ°å®ä½“å’Œ DTO
   - å¤–éƒ¨ä¾èµ–

2. **æ¨¡å—æ³¨å†Œ**

   - åœ¨ `{module}.module.ts` ä¸­æ³¨å†Œæ‰€æœ‰æœåŠ¡
   - åœ¨ `TypeOrmModule.forFeature()` ä¸­æ³¨å†Œå®ä½“
   - æ­£ç¡®é…ç½®ä¾èµ–æ³¨å…¥

3. **æœåŠ¡åˆ†å±‚åŸåˆ™**
   - **æ•°æ®è®¿é—®å±‚ (Repository)**ï¼šä¸“æ³¨äºæ•°æ®åº“æ“ä½œï¼Œæä¾›åŸºç¡€ CRUD åŠŸèƒ½
   - **ä¸šåŠ¡æœåŠ¡å±‚ (Service)**ï¼šå¤„ç†ä¸šåŠ¡é€»è¾‘ç¼–æ’ï¼Œäº‹åŠ¡ç®¡ç†ï¼Œè·¨æ¨¡å—è°ƒç”¨
   - **ç‰¹æ€§æœåŠ¡å±‚ (FeatureService)**ï¼šå¤„ç†ç‰¹å®šåŠŸèƒ½é¢†åŸŸçš„ä¸šåŠ¡é€»è¾‘
   - **æ§åˆ¶å™¨å±‚ (Controller)**ï¼šå¤„ç† HTTP è¯·æ±‚ï¼Œå‚æ•°éªŒè¯ï¼Œå“åº”æ ¼å¼åŒ–

### ğŸ“Š åˆ†å±‚ä½¿ç”¨æŒ‡å—

#### ä½•æ—¶ä½¿ç”¨ Repository å±‚

- éœ€è¦å¤æ‚çš„æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
- éœ€è¦ç»Ÿä¸€çš„æ•°æ®è®¿é—®æ¥å£
- éœ€è¦æ•°æ®è®¿é—®å±‚çš„å•å…ƒæµ‹è¯•
- éœ€è¦æ”¯æŒå¤šç§æ•°æ®æº

#### ä½•æ—¶ä½¿ç”¨ Service å±‚

- éœ€è¦ç¼–æ’å¤šä¸ªæ•°æ®æ“ä½œ
- éœ€è¦äº‹åŠ¡ç®¡ç†
- éœ€è¦è°ƒç”¨å¤–éƒ¨æœåŠ¡
- éœ€è¦å¤æ‚çš„ä¸šåŠ¡è§„åˆ™éªŒè¯

#### ä½•æ—¶ä½¿ç”¨ FeatureService å±‚

- åŠŸèƒ½ç›¸å¯¹ç‹¬ç«‹ä¸”å¤æ‚
- éœ€è¦ä¸“é—¨çš„ä¸šåŠ¡é€»è¾‘å¤„ç†
- å¯ä»¥è¢«å¤šä¸ª Service å¤ç”¨
- æœ‰æ˜ç¡®çš„åŠŸèƒ½è¾¹ç•Œ

#### ç®€åŒ–åŸåˆ™

- å¯¹äºç®€å•çš„ CRUD æ“ä½œï¼Œå¯ä»¥ç›´æ¥åœ¨ Service ä¸­æ³¨å…¥ Repository
- å¯¹äºå¤æ‚çš„ä¸šåŠ¡åœºæ™¯ï¼Œå»ºè®®ä½¿ç”¨å®Œæ•´çš„åˆ†å±‚æ¶æ„
- æ ¹æ®é¡¹ç›®å¤æ‚åº¦çµæ´»é€‰æ‹©åˆ†å±‚æ·±åº¦
